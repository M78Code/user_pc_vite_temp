




     逻辑块 A  {
       ==》调用当前数据仓库 读取当前mid 的 mid_obj
       ==》直接设置 详情数据仓库 set_list([obj])

      }
    逻辑块 B  {
        ==》   /w/matchDetail/getMatchDetail  +    /matchDetail/getMatchOddsInfo2
        ==》   组装数据  初始化 数据仓库
        ==》   设置 详情数据仓库 set_list([obj])
      }

逻辑块 A  和    逻辑块 B  差异 

两种流程： 逻辑块 A 走完 ===》【 设置mid | 跳转 |各种其他】 进到目标组件 ===》 逻辑块 B 
两种流程： 逻辑块 B 

 
  PC   列表 和 详情  之间的 数据中间件 





整体宗旨： 
1.假设以前有数据 数据仓库不是同一个 ：那就 逻辑块 A 
2.假设之前没数据  逻辑块 B 
  
场景 A  {
      1. 列表跳转 详情的 ：
    ==》跳转详情之前 
    ==》逻辑块 A 
    ==》跳转详情
  
}
  
  2.  详情跳转列表 
           赛事已结束： {
           ==> 拉取一次元数据 ，菜单和 列表队列映射关系  
           }
           赛事没有结束：{
             不用去数据同步
             ===》读取之前存的 来源菜单 来源页面 
             ===》调用菜单那边的方法  设置 要用的菜单 
             ===》切路由 
             ===》列表走自己的 整体逻辑
            
           }
  
   3.在主列表内 的右侧详情 ：{
         case A :  {
             特征： 列表内有这个赛事
             例如： 点击 列表内赛事 展示右侧详情 
             
            ==》    [逻辑块 A] 
         }
          case B  :  {
            特征：列表内没有这个赛事
            例如： 1. 右侧详情切换同联赛赛事
                  2.菜单切换 保留之前的 右侧，产品要求的各种右侧 不和中间同步
                  3.例如右侧赛事自动切换,看产品要求
            ==》    [逻辑块 B] 
         }

    }

   4. 在详情内的 左侧详情 
    
      case A {
        url 直接进详情 ：
        ==》 [逻辑块 B] 
      }
      case B {
         列表 进详情 ：
        ==》 场景 A 
      }
      case C {
            活动 banner 等非列表进详情 ：
        ==》 [逻辑块 B] 
      }
   5. 在详情内的 右侧详情 
    
      case A {
         从详情同步 详情
         ==》 逻辑块 A

      }
  
   5. 在详情内的 右侧小列表 点击 同步 左侧 详情 
    
      case A {
         从列表同步 详情
         ==》 逻辑块 A

      }
  



 
            
   
  需要存储：
   1. 从哪里来  ， （为了 知道 往哪里返回）  
  
  
 