


202311.19 讨论结果：
先ref 数据仓库实例先看性能   ，如果不行再参照下面的方案尝试


原生对象： obj
ref对象： proxy


基准： 只用了一两个小属性点，绝对不能 ref 一个庞大的对象转 proxy



数据仓库 实例   仓库1  



列表循环==》 列表队列 ===》列表表征==》  


==》元数据拿基础信息==》设置数据仓库==》 循环列表表征
  ==》赛事级别卡片==》{
  ==》赛事基础信息逻辑==>{
   ==>数据仓库拿赛事信息==》{
    //以前的版本 是 各种需要变的 ，都自己watch自己需要的
    包含原来直接读取显示的：{
        主客队信息，玩法数量
    }
    需要计算的：{
        赛事阶段，计时器，比分，提前结算状态 、动画、视频、状态
    }
    方案1： 处理各种 ，包含原来直接读取显示的 和需要计算的
    定时器赛事状态自循环， 可以同步更新整个元数据区域需要更新的 ， 父级提升， 父子组件关系
    //
    方案2：  mid_obj ： ref(包含原来直接读取显示的：)  ref(mid_obj[xx]['xsxs'])     {bi:'1:1'}

   }

 }
   ==》 玩法级别信息逻辑==》{
    读取当前的卡片模板==》拿到玩法ID==》数据仓库拿到hpid 对象（玩法级别对象）
    ==》每个玩法 oid_obj ==》根据模板填坑(达成目标：静态渲染)
    ==》动态渲染：{
        问题：
        1.WS推送的单个投注项级别的赔率变更，没有去更新 oid_obj的版本号
        2.坑位玩法的单个位置的 oid 会变
        3.非坑位玩法的oid 一般不变 ，但是如果玩法级别hid 都改了这个时候 oid 一定变化
           例如 chpid : 13-1  ==> 13-6  , 255==>123
       方案：
       解决2和3：  赛事级别version 变更 ，【重走上面流程快】 ，为了拿到 hpid  根据模板循环对象
       解决1：
         可以 ref oid_obj[oid]
         ===> 红升绿降： 判断mid ， chpid ，  组件内 自己 ，留存上一次的盘口赔率和这一次的 ，（3秒定时红升绿降 ！）
        raw 对象 ， 因为根源都在 oid_obj ， 地址一样 自动会变

    }

 }

 }




